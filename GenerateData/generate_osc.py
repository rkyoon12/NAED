# -*- coding: utf-8 -*-
"""forcedosc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ld5hxioK7AG_KYWSO8XBY9A4oJCwW8xz

For RNN,LSTM,CFN, need to use the same file in the shared folder. It's for equation discovery
"""

import numpy as np
import tensorflow as tf
import scipy.integrate
import scipy.special

from google.colab import drive
drive.mount('/content/gdrive')

path = "/content/gdrive/My Drive/Colab Notebooks"

# amazingly, this fixes plotting on Harish's Mac!
import os

os.environ['KMP_DUPLICATE_LIB_OK']='True'

# create data
# global variables
def createoneinstance(alpha, zeta, T, gamma=0.2, omega=1.0):
    def forcing(t):
        out = np.dot(zeta, np.sin(alpha*t))
        return out
    
    def rhs(t,y):
        yout = np.zeros(y.shape)
        yout[0,:] = y[1,:]
        yout[1,:] = -gamma*y[1,:] -omega**2*y[0,:] + forcing(t)
        return yout
    
    # in case we need intermediate points:
    # t_eval=np.linspace(0, T, 100),
                                    
    sol = scipy.integrate.solve_ivp(fun=rhs, 
                                    t_span=[0, T], 
                                    y0=[0.,0.], 
                                    vectorized=True)
    
    prob = scipy.special.expit(sol.y[0,-1])
    
   
    return (1)*(prob >= 0.5)

alpha = 1
z = 1

createoneinstance(alpha, z, 10, gamma=0.2, omega=1.0)

nrows = 10000
tslen = 100

# x will be a matrix of input forcings (not ODE solutions)
x = np.zeros((nrows, tslen))

# y will be binary labels
y = np.zeros((nrows, 1), dtype='int32')

for i in range(nrows):
    # a and z are frequencies and coefficients of the forcing
    # could be any dimension, 2 is arbitrary here
    a = np.random.normal(size=2)
    z = np.random.normal(size=2)
    if i == 0:
      a0 = a
      z0= z
    
    # deterministic final time, could generalize this later
    fT = 10.0
    t = np.linspace(0, fT, tslen)
    x[i, :] = np.dot(z, np.sin(np.outer(a, t)))
    #y[i] = createoneinstance(a,z,fT)
    # y = sigma( h(10))
    y[i] = createoneinstance(a,z,fT)

# %% Define derivative function
def f(t, y,zeta, alpha):
  dydt = [y[1] , -y[0]-0.2*y[1]+zeta[0]*np.sin(alpha[0]*t) +zeta[1]*np.sin(alpha[1]*t) ]
  return dydt
 
tspan = np.linspace(0, 10, 100)
yinit = [0, 0]
solvedh1 = []
solvedh2 = []

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
        
# %% Solve differential equation
sol = solve_ivp(lambda t, y: f(t, y,z0,a0)  , [tspan[0], tspan[-1]], yinit, t_eval=tspan)

# plotting h1 and h2 for the LAST instance.

# %% Plot states
fig1, axs1 = plt.subplots(nrows=1, ncols=2, sharex=True)
ax1 = axs1[0]
ax1.plot(sol.y[0])
ax1.set_title('original h1')

ax2 = axs1[1]
ax2.plot(sol.y[1])
ax2.set_title('original h2')

plt.show()

print(y[-1])

x = x.reshape((nrows,tslen,1))
y = y.reshape((nrows,1))

n_train = 8000

X_train = x[:n_train,:,:]
X_test = x[n_train:,:,:]

y_train = y[:n_train,:]
y_test = y[n_train:,:]

import pickle
with open(path + '/' + 'forcedosc7.pickle','wb') as f:
  
    pickle.dump([X_train, y_train, X_test, y_test], f)

import pickle
with open(path + '/' + 'small_forced7.pickle','wb') as f:
  
    pickle.dump([X_train, y_train, X_test, y_test], f)

