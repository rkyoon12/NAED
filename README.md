

<!-- PROJECT LOGO -->
<br />
<p align="center">
 
  

  <h3 align="center">A non-autonomous equation discovery method for time signal classification</h3>

  <p align="center">
    Document is available below
    <br />
    <a href="https://arxiv.org/pdf/2011.11096.pdf"><strong>Explore the docs Â»</strong></a>
    <br />
    <br />
    
  </p>
</p>




<!-- ABOUT THE PROJECT -->
## About The Project

This paper proposes a non-autonomous dynamical system framwork for time signal classification. We view time signal data $x(t)$ as continuous forcing term in a non-autonomous dynamical system of hidden variable $h:[0,T] \rightarrow \mathbb{R}^m$,
$$
\frac{d}{dt} h(t) = \Phi(h(t),x(t);\theta), \qquad h(0) = h_0.
$$
Then the solution at the final time $T$ is used to make a class prediction $\hat{y}$ via 
$$
\hat{y} = \sigma(Ah(T) + b).
$$


* Based on the Equation discovery method, the vector field $\Phi$ is defined by Dictionary elements. 
* Using the adjoint method, compute the gradients of objective by solving alternative adjoint equation. 
* Applying the stability theory, we analyze the stability of classifier under the noise in the given data. 
* Benchmark SINDy algorithm, we thresholding the coefficients by cutoff value to prevent overfitting.

Tensorflow is required to run the code. 

<!-- Usage Example -->
## Usage Example
Explore the example which shows how this code run for time-signal classification. 

### 1. Dataset

Here, we use the synthetic data generated by the forced harmonic oscillator. For given forcing $x(t)= \Sigma_{k=1}^K A_k\sin(\alpha_k t)$, solve

$$\ddot{u} + \gamma \dot{u} + \omega u = x(t),\qquad u(0) = \dot{u} = 0.$$
Then the class will be assigned depending on the position of solution (either positive or negative) at final time $T$. The time series $x$ and label $y$ is pickled in  [osc.pickle](https://github.com/rkyoon12/NAED/blob/master/GenerateData/osc.pickle). Modifying the dynamical system in [generate_osc.py](https://github.com/rkyoon12/NAED/blob/master/GenerateData/generate_osc.py), you can generate the other synthetic dataset. 

### 2. Dictionary choice. 

In the NAED model, the right-hand side of dynamical system is given by $\Phi = \beta \Xi(h) + Bx$. Here we can pre-specify the entries of $\Xi(h)$. We  tested NAED model using two different dictionaries;  polynomials and Fouriers. The examples of dictionary is described in the document [paper](https://arxiv.org/pdf/2011.11096.pdf).


### 

This shows how to customize the dictionary in the main code. 
* Polynomial dictionary

 Polynomial dictionary consists of all possible polynomials of $h\in \mathbb{R}^m$ upto $k$-th order. For instance, $m = 2, k= 1$ then, then dictionary consists of  $\Xi(h) = [1,h_1,h_2]$. In the code [poly21](https://github.com/rkyoon12/NAED/blob/master/Main/poly21.py), you can change both dimension of $h$ and maximum degree of polynomials.

  ```sh
  # m : dimension of hidden variables
  # maximum degree = maxdeg - 1
  m = 2
  maxdeg = 2

  ```
* Fourier dictionary

 Fourier dictionary consists of outer product of fourier elements with respective frequency.  For instance, $m = 2, K= 1$ then, then dictionary consists of 
$$ \small
\Xi(h) =  \Big[  1, 
\cos\left( 2\pi h_1/L\right),  \sin\left( 2\pi  h_1/L\right), 
\cos\left(2\pi h_2/L\right), 
\sin\left( 2\pi  h_2/L\right), 
\cos\left( 2\pi h_1/L\right)
\cos\left( 2\pi h_2/L\right),$$
$$\small
\qquad \sin\left( 2\pi h_1/L\right) 
 \cos\left( 2\pi h_2/L\right), 
\cos\left(2\pi h_1/L\right) 
\sin\left( 2\pi  h_2/L\right), 
\sin\left( 2\pi h_1/L\right)
\sin\left( 2\pi  h_2/L\right) \Big]. 
$$
In the codes [Fourier21](https://github.com/rkyoon12/NAED/blob/master/Main/Fourier21.py) and [Fourier22](https://github.com/rkyoon12/NAED/blob/master/Main/Fourier22.py), dictionary elements are manually written. 
 ```sh
# m : dimension of hidden variables
# mul : 2*pi/period 

mul = 2*np.pi/10 
m = 2

def bigxi2(ht):
    h1 = mul*ht[:,0]
    h2 = mul*ht[:,1]
    return tf.transpose(tf.constant([np.ones(ht.shape[0]), np.cos(h1), np.sin(h1), np.cos(h2), np.cos(h2)*np.cos(h1),
                                  np.cos(h2)*np.sin(h1), np.sin(h2), np.sin(h2)*np.cos(h1), np.sin(h2)*np.sin(h1)]
                                  ,dtype = 'float32'))
  ```

### 3. Optimization

This model is trained using the gradient-based method "ADAM" with the constant learning rate. Depending on your problem, change learning rate and optimizer in keras. 

 ```
lr = 0.01
bce = tf.keras.losses.BinaryCrossentropy()
opt = tf.keras.optimizers.Adam(learning_rate=lr)

  ```


<!-- Results -->
## Results  

We presents the accuracy of classification and depict the learned vector fields. 
[stack overflow](https://github.com/rkyoon12/NAED/blob/master/images/OSC_final.eps)


For more examples, please refer to the [paper](https://arxiv.org/pdf/2011.11096.pdf).





<!-- CONTACT -->
## Contact
Ryeongkyung Yoon - rkyoon@math.utah.edu

Project Link: [https://github.com/rkyoon12/NAED-Method](https://github.com/rkyoon12/NAED-Method)


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQ0NjYyMTg0OSwtMjA2MTQzMjc4LC0xMz
EyOTE1NDMwLC0xMzEyOTE1NDMwLC05ODE5MDExMzddfQ==
-->