<!--
*** Thanks for checking out the Best-README-Template. If you have a suggestion
*** that would make this better, please fork the repo and create a pull request
*** or simply open an issue with the tag "enhancement".
*** Thanks again! Now go create something AMAZING! :D
***
***
***
*** To avoid retyping too much info. Do a search and replace for the following:
*** github_username, repo_name, twitter_handle, email, project_title, project_description
-->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$'] ],
    processEscapes: true,
  }
});
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



<!-- PROJECT LOGO -->
<br />
<p align="center">
 
  

  <h3 align="center">A non-autonomous equation discovery method for time signal classification</h3>

  <p align="center">
    Document is available below
    <br />
    <a href="https://arxiv.org/pdf/2011.11096.pdf"><strong>Explore the docs Â»</strong></a>
    <br />
    <br />
    
  </p>
</p>




<!-- ABOUT THE PROJECT -->
## About The Project

This paper proposes a non-autonomous dynamical system framwork for time signal classification. We view time signal data $x(t)$ as continuous forcing term in a non-autonomous dynamical system of hidden variable $h:[0,T] \rightarrow \mathbb{R}^m$,
$$
\frac{d}{dt} h(t) = \Phi(h(t),x(t);\theta), \qquad h(0) = h_0.
$$
Then the solution at the final time $T$ is used to make a class prediction $\hat{y}$ via 
$$
\hat{y} = \sigma(Ah(T) + b).
$$


* Based on the Equation discovery method, the vector field $\Phi$ is defined by Dictionary elements. 
* Using the adjoint method, compute the gradients of objective by solving alternative adjoint equation. 
* Applying the stability theory, we analyze the stability of classifier under the noise in the given data. 
* Benchmark SINDy algorithm, we thresholding the coefficients by cutoff value to prevent overfitting.

Tensorflow is required to run the code. 

<!-- Usage Example -->
## Usage Example
Explore the example which shows how this code run for time-signal classification. 

### 1. Dataset

Here, we use the synthetic data generated by the forced harmonic oscillator. For given forcing $x(t)= \Sigma_{k=1}^K A_k\sin(\alpha_k t)$, solve

$$\ddot{u} + \gamma \dot{u} + \omega u = x(t),\qquad u(0) = \dot{u} = 0.$$
Then the class will be assigned depending on the position of solution (either positive or negative) at final time $T$. The time series $x$ and label $y$ is pickled in  [osc.pickle](https://github.com/github_username/repo_name/issues). Modifying the dynamical system in [generate_osc.py](https://github.com/github_username/repo_name/issues), you can generate the other synthetic dataset. 

### 2. Dictionary choice. 

In the NAED model, the right-hand side of dynamical system is given by $\Phi = \beta \Xi(h) + Bx$. Here we can pre-specify the entries of $\Xi(h)$. We  tested NAED model using two different dictionaries;  polynomials and Fouriers. The examples of dictionary is described in the document [paper](https://arxiv.org/pdf/2011.11096.pdf).


### 

This shows how to customize the dictionary in the main code. 
* Polynomial dictionary

 Polynomial dictionary consists of all possible polynomials of $h\in \mathbb{R}^m$ upto $k$-th order. For instance, $m = 2, k= 1$ then, then dictionary consists of  $\Xi(h) = [1,h_1,h_2]$. In the code [poly21](https://arxiv.org/pdf/2011.11096.pdf), you can change both dimension of $h$ and maximum degree of polynomials.

  ```sh
  # m : dimension of hidden variables
  # maximum degree = maxdeg - 1
  m = 2
  maxdeg = 2

  ```
* Fourier dictionary

 Fourier dictionary consists of outer product of fourier elements with respective frequency.  For instance, $m = 2, K= 1$ then, then dictionary consists of 
$$ \small
\Xi(h) =  \Big[  1, 
\cos\left( 2\pi h_1/L\right),  \sin\left( 2\pi  h_1/L\right), 
\cos\left(2\pi h_2/L\right), 
\sin\left( 2\pi  h_2/L\right), 
\cos\left( 2\pi h_1/L\right)
\cos\left( 2\pi h_2/L\right),$$
$$\small
\qquad \sin\left( 2\pi h_1/L\right) 
 \cos\left( 2\pi h_2/L\right), 
\cos\left(2\pi h_1/L\right) 
\sin\left( 2\pi  h_2/L\right), 
\sin\left( 2\pi h_1/L\right)
\sin\left( 2\pi  h_2/L\right) \Big]. 
$$
In the codes [Fourier21](https://arxiv.org/pdf/2011.11096.pdf) and [Fourier22](https://arxiv.org/pdf/2011.11096.pdf), dictionary elements are manually written. 
 ```sh
# m : dimension of hidden variables
# mul : 2*pi/period 

mul = 2*np.pi/10 
m = 2

def bigxi2(ht):
    h1 = mul*ht[:,0]
    h2 = mul*ht[:,1]
    return tf.transpose(tf.constant([np.ones(ht.shape[0]), np.cos(h1), np.sin(h1), np.cos(h2), np.cos(h2)*np.cos(h1),
                                  np.cos(h2)*np.sin(h1), np.sin(h2), np.sin(h2)*np.cos(h1), np.sin(h2)*np.sin(h1)]
                                  ,dtype = 'float32'))
  ```

### 3. Dictionary choice. 

This model is trained using the gradient-based method "ADAM" with the constant learning rate. Depending on your problem, change learning rate and optimizer in keras. 

 ```
lr = 0.01
bce = tf.keras.losses.BinaryCrossentropy()
opt = tf.keras.optimizers.Adam(learning_rate=lr)

  ```


<!-- Results -->
## Results  

We presents the accuracy of classification and depict the learned vector fields. 

![images](/path/to/img.jpg)


For more examples, please refer to the [paper](https://arxiv.org/pdf/2011.11096.pdf).





<!-- CONTACT -->
## Contact
Ryeongkyung Yoon - rkyoon@math.utah.edu

Project Link: [https://github.com/rkyoon12/NAED-Method](https://github.com/rkyoon12/NAED-Method)


